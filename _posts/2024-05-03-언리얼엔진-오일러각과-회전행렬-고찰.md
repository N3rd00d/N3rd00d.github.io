---
title: "언리얼엔진 오일러각과 회전행렬 고찰"
description: "언리얼 엔진에서 회전각을 역회전행렬로 변환하는 FInverseRotationMatrix 클래스의 생성자는 다음과 같다.역행렬의 성질에 따라$Y^{-1}P^{-1}R^{-1}=(RPY)^{-1}$임을 생각해본다면, 본디 축회전연산의 순서는 Roll-Pitch-Yaw 순임"
date: 2024-05-03T15:43:50.159Z
tags: ["matrix","rotation","unreal"]
---
# 오일러각과 회전행렬

언리얼 엔진에서 회전각을 역회전행렬로 변환하는 `FInverseRotationMatrix` 클래스의 생성자는 다음과 같다.

![](/images/0211955a-7adb-451f-889d-880ee974d3a3-image.png)

역행렬의 성질에 따라
$Y^{-1}P^{-1}R^{-1}=(RPY)^{-1}$
임을 생각해본다면, 본디 축회전연산의 순서는 Roll-Pitch-Yaw 순임을 알 수 있다.

또한, 이들 회전행렬은 직교행렬이기에
$A^{-1} = A^T$ 
와 같다. 따라서, 언리얼엔진에서 쓰는 Roll, Pitch, Yaw의 회전행렬을 알 수 있다.
- x축 회전 - Roll
$$R=\begin{pmatrix} 
1 & 0 & 0 & 0 \\
0 & cosR & -sinR & 0 \\
0 & sinR & cosR & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}$$
- y축 회전 - Pitch
$$P=\begin{pmatrix} 
cosP & 0 & sinP & 0 \\
0 & 1 & 0 & 0 \\
-sinP & 0 & cosP & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}$$
- z축 회전 - Yaw
$$Y=\begin{pmatrix} 
cosY & sinY & 0 & 0 \\
-sinY & cosY & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}$$

이제 모두 곱하여 회전 복합행렬을 만들 수 있다.
$$
RPY = 
\begin{pmatrix} 
cosPcosY & cosPsinY & sinP & 0 \\
sinRsinPcosY-cosRsinY & sinRsinPsinY+cosRcosY & -sinRcosP & 0 \\
-cosRsinPcosY-sinRsinY & -cosRsinPsinY+sinRcosY & cosRcosP & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$$

실제로 `FRotationTranslationMatrix` 클래스의 생성자 구현코드를 보면, 각 요소들의 계산이 위 행렬과 같음을 확인해볼 수 있다.

```c++
FORCEINLINE FRotationTranslationMatrix::FRotationTranslationMatrix(const FRotator& Rot, const FVector& Origin)
{
#if PLATFORM_ENABLE_VECTORINTRINSICS

	const VectorRegister Angles = MakeVectorRegister(Rot.Pitch, Rot.Yaw, Rot.Roll, 0.0f);
	const VectorRegister HalfAngles = VectorMultiply(Angles, GlobalVectorConstants::DEG_TO_RAD);

	union { VectorRegister v; float f[4]; } SinAngles, CosAngles;
	VectorSinCos(&SinAngles.v, &CosAngles.v, &HalfAngles);

	const float	SP	= SinAngles.f[0];
	const float	SY	= SinAngles.f[1];
	const float	SR	= SinAngles.f[2];
	const float	CP	= CosAngles.f[0];
	const float	CY	= CosAngles.f[1];
	const float	CR	= CosAngles.f[2];

#else
	...	

#endif // PLATFORM_ENABLE_VECTORINTRINSICS

	M[0][0]	= CP * CY;
	M[0][1]	= CP * SY;
	M[0][2]	= SP;
	M[0][3]	= 0.f;

	M[1][0]	= SR * SP * CY - CR * SY;
	M[1][1]	= SR * SP * SY + CR * CY;
	M[1][2]	= - SR * CP;
	M[1][3]	= 0.f;

	M[2][0]	= -( CR * SP * CY + SR * SY );
	M[2][1]	= CY * SR - CR * SP * SY;
	M[2][2]	= CR * CP;
	M[2][3]	= 0.f;

	M[3][0]	= Origin.X;
	M[3][1]	= Origin.Y;
	M[3][2]	= Origin.Z;
	M[3][3]	= 1.f;
}
```

# Pitch, Roll 축의 반시계 회전
언리얼 엔진은 왼손좌표계이고 Z-up을 사용한다. 따라서, 회전축들은 시계 방향으로 회전하게 된다. 그러나, Roll, Pitch축은 언뜻 시계방향으로 회전하는 것처럼 느껴질 수 있으나 사실은 반시계 방향으로 회전한다. 이는 의도된 언리얼 엔진의 회전축 정책으로, 그 이유는 아무도 모른다.

언리얼 엔진을 켜고 어떤 액터의 축이 나아가는 방향의 정면으로 카메라를 이동한 뒤 회전을 시켜보자. 아래 그림처럼 왼손좌표계를 그대로 따른다면 시계방향으로 회전하겠지만.. 실제로 해보면 Pitch, Roll이 반시계로 회전됨을 확인할 수 있다.

![](/images/ff7596f4-c00c-40e6-b3d4-c7542866c040-image.png)


이에 최근 일관적이지 못한 축회전에 대해 많은 사람들이 의문을 제기하였는지, UE 5.1 버전으로 올라오면서 FRotator 클래스의 주석이 변경되었다.

![](/images/df9d5003-cae9-43ff-b5ec-a7d65f4409fa-image.png)

```
각도는 Yaw, Pitch, Roll 순서로 적용되는 본질적인 회전으로 해석됩니다. 즉, 객체는 먼저 지정된 Yaw로 up-z(위에서 볼 때 시계 방향이 양의 각도로 해석됨, -Z 방향)을 중심으로 회전하고, 그 다음으로 (새로운) 오른쪽 축을 중심으로 Pitch(양의 각도는 nose-up으로 해석되며, +Y 방향을 따라 볼 때 시계 방향), 마지막으로 (최종) 전방 축을 중심으로 Roll(양의 각도는 +X 방향을 따라 볼 때 시계 방향의 회전으로 해석됨)합니다.  
이러한 관례는 쿼터니언 축/각도와 다릅니다. UE Quat는 항상 양의 각도를 왼손 회전으로 간주하지만, Rotator는 Yaw를 왼손으로, Pitch와 Roll을 오른손으로 처리합니다.
```

>Rotator는 Yaw를 왼손좌표계로, Pitch와 Roll을 오른손좌표계로 처리합니다.

이에 독자분들은 회전연산을 직접 구현해 처리할 적엔 이런 요상한 축회전 방향 규칙을 기억하길 바란다.

# 마무리하며
아래 스크린샷은 msdn에서 dx9의 회전행렬에 대한 설명글의 일부를 캡쳐한 것이다.

![](/images/a90daa1a-2af4-431d-b0d0-1369d300fdab-image.png)

 다시 처음으로 돌아가, 1년전 언리얼 엔진을 처음 만져볼 때 `FInverseRotationMatrix`의 생성자 코드를 보던 중, 필자는 FRotator 매개변수로 변환된 Roll, Pitch의 역회전 행렬은 위 스크린샷의 x-axis, y-axis 회전행렬의 역행렬과 왜 다른 것인지 가벼운 의문을 품은 바 있었다. 사내의 급한 업무가 우선이라 다음 기회로 미루었지만, 금일 기초수학물리책을 다시 일독함에 갑자기 생각이 나서 이 글을 쓰게 되었다.