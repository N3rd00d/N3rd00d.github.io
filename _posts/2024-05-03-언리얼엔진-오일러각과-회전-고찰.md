---
title: "언리얼엔진 오일러각과 회전 고찰"
description: "언리얼 엔진에서 회전각을 역회전행렬로 변환하는 FInverseRotationMatrix 클래스의 생성자는 다음과 같다.역행렬의 성질에 따라$Y^{-1}P^{-1}R^{-1}=(RPY)^{-1}$임을 생각해본다면, 본디 축회전연산의 순서는 Roll-Pitch-Yaw 순임"
date: 2024-05-03T15:43:50.159Z
tags: ["matrix","rotation","unreal"]
---
# 오일러각과 회전행렬

언리얼 엔진에서 회전각을 역회전행렬로 변환하는 `FInverseRotationMatrix` 클래스의 생성자는 다음과 같다.

![](/images/0211955a-7adb-451f-889d-880ee974d3a3-image.png)

역행렬의 성질에 따라
$Y^{-1}P^{-1}R^{-1}=(RPY)^{-1}$
임을 생각해본다면, 본디 축회전연산의 순서는 Roll-Pitch-Yaw 순임을 알 수 있다.

또한, 이들 회전행렬은 직교행렬이기에
$A^{-1} = A^T$ 
이다. 따라서, 언리얼엔진에서 쓰는 Roll, Pitch, Yaw의 회전행렬을 알 수 있다.
- x축 회전 - Roll
$$R=\begin{pmatrix} 
1 & 0 & 0 & 0 \\
0 & cosR & -sinR & 0 \\
0 & sinR & cosR & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}$$
- y축 회전 - Pitch
$$P=\begin{pmatrix} 
cosP & 0 & sinP & 0 \\
0 & 1 & 0 & 0 \\
-sinP & 0 & cosP & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}$$
- z축 회전 - Yaw
$$Y=\begin{pmatrix} 
cosY & sinY & 0 & 0 \\
-sinY & cosY & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}$$

이제 모두 곱하여 회전 복합행렬을 만들 수 있다.
$$
RPY = 
\begin{pmatrix} 
cosPcosY & cosPsinY & sinP & 0 \\
sinRsinPcosY-cosRsinY & sinRsinPsinY+cosRcosY & -sinRcosP & 0 \\
-cosRsinPcosY-sinRsinY & -cosRsinPsinY+sinRcosY & cosRcosP & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$$

실제로 `FRotationTranslationMatrix` 클래스의 생성자 구현코드를 보면, 각 요소들의 계산이 위 행렬과 같음을 확인해볼 수 있다.

```c++
FORCEINLINE FRotationTranslationMatrix::FRotationTranslationMatrix(const FRotator& Rot, const FVector& Origin)
{
#if PLATFORM_ENABLE_VECTORINTRINSICS

	const VectorRegister Angles = MakeVectorRegister(Rot.Pitch, Rot.Yaw, Rot.Roll, 0.0f);
	const VectorRegister HalfAngles = VectorMultiply(Angles, GlobalVectorConstants::DEG_TO_RAD);

	union { VectorRegister v; float f[4]; } SinAngles, CosAngles;
	VectorSinCos(&SinAngles.v, &CosAngles.v, &HalfAngles);

	const float	SP	= SinAngles.f[0];
	const float	SY	= SinAngles.f[1];
	const float	SR	= SinAngles.f[2];
	const float	CP	= CosAngles.f[0];
	const float	CY	= CosAngles.f[1];
	const float	CR	= CosAngles.f[2];

#else
	...	

#endif // PLATFORM_ENABLE_VECTORINTRINSICS

	M[0][0]	= CP * CY;
	M[0][1]	= CP * SY;
	M[0][2]	= SP;
	M[0][3]	= 0.f;

	M[1][0]	= SR * SP * CY - CR * SY;
	M[1][1]	= SR * SP * SY + CR * CY;
	M[1][2]	= - SR * CP;
	M[1][3]	= 0.f;

	M[2][0]	= -( CR * SP * CY + SR * SY );
	M[2][1]	= CY * SR - CR * SP * SY;
	M[2][2]	= CR * CP;
	M[2][3]	= 0.f;

	M[3][0]	= Origin.X;
	M[3][1]	= Origin.Y;
	M[3][2]	= Origin.Z;
	M[3][3]	= 1.f;
}
```

## Pitch, Roll 축의 반시계 회전

다음은 msdn dx9 축 회전행렬 부분을 스크린샷한 것이다. 자세히보면 아래 x, y축 회전행렬이 위 언리얼의 x, y축 회전행렬과 전치되어 있음을 알 수 있다.

![](/images/a90daa1a-2af4-431d-b0d0-1369d300fdab-image.png)

이는 곧 역행렬이라, 회전에서 그 의미는 반대방향으로의 회전을 의미한다.

언리얼 엔진을 켜고 어떤 액터의 축이 나아가는 방향의 정면으로 카메라를 이동한 뒤 회전을 시켜보자. 아래 그림처럼 왼손좌표계를 그대로 따른다면 시계방향으로 회전하겠지만.. 실제로 해보면 Pitch, Roll이 반시계로 회전됨을 확인할 수 있다.

![](/images/ff7596f4-c00c-40e6-b3d4-c7542866c040-image.png)

그렇다. 언리얼 엔진은 z-up의 왼손좌표계를 사용하지만, Yaw는 시계방향으로 Roll, Pitch축은 반시계 방향으로 회전한다. 이는 의도된 언리얼 엔진의 회전축 정책으로, 그 이유는 모르겠다.

최근 일관적이지 못한 축회전에 대해 많은 사람들이 의문을 제기하였는지, UE 5.1 버전으로 올라오면서 FRotator 클래스의 주석이 변경되었다.

![](/images/df9d5003-cae9-43ff-b5ec-a7d65f4409fa-image.png)

```
각도는 Yaw, Pitch, Roll 순서로 적용되는 본질적인 회전으로 해석됩니다. 즉, 객체는 먼저 지정된 Yaw로 up-z(위에서 볼 때 시계 방향이 양의 각도로 해석됨, -Z 방향)을 중심으로 회전하고, 그 다음으로 (새로운) 오른쪽 축을 중심으로 Pitch(양의 각도는 nose-up으로 해석되며, +Y 방향을 따라 볼 때 시계 방향), 마지막으로 (최종) 전방 축을 중심으로 Roll(양의 각도는 +X 방향을 따라 볼 때 시계 방향의 회전으로 해석됨)합니다.  
이러한 관례는 쿼터니언 축/각도와 다릅니다. UE Quat는 항상 양의 각도를 왼손 회전으로 간주하지만, Rotator는 Yaw를 왼손으로, Pitch와 Roll을 오른손으로 처리합니다.
```

>Rotator는 Yaw를 왼손좌표계로, Pitch와 Roll을 오른손좌표계로 처리합니다.

이에 회전연산을 직접 구현해 처리할 적엔 이 요상한 축회전 규칙에 주의하여야 한다.

# 오일러각과 쿼터니언
## 오일러각으로 쿼터니언 만들기
위 오일러각과 회전행렬처럼 각 x,y,z(Roll-Pitch-Yaw) 축 순서로 회전행렬을 곱해 복합행렬을 만든 것처럼, 각 오일러각을 단계적으로 적용해 쿼터니언을 만들 수 있다. 
- $x'=x*PI/180$, $y'=y*PI/180$, $z'=z*PI/180$
- x축(Roll)으로 회전하는 쿼터니언 $q_x = cr+sri$, $(cr = cos\frac{x'}{2}, sr = sin\frac{x'}{2})$
- y축(Roll)으로 회전하는 쿼터니언 $q_y = cp+spj$, $(cp = cos\frac{y'}{2}, sp = sin\frac{y'}{2})$
- z축(Yaw)으로 회전하는 쿼터니언 $q_z = cy+syk$, $(cy = cos\frac{z'}{2}, sy = sin\frac{z'}{2})$

그런데, 우리는 위에서 Pitch와 Roll이 방향이 언리얼엔진에선 오른손좌표 즉, 시계반대방향으로 회전함을 알고 있다. 따라서, x, y 축으로 회전하는 쿼터니언 허수부의 부호를 반대로 한다.
- $q_x = cr-sri$
- $q_y = cp-spj$
- $q_z = cy+syk$

이렇게 만들어진 x,y,z축 회전 쿼터니언들을 역순($q_z q_y q_x$)으로 곱해야한다.
![](/images/08fa6771-989a-4700-a87f-542af08c1ae3-image.png)


$q_z q_y q_x$
$=(cy+syk)(cp-spj)(cr-sri)$
$=(cpcy-spcyj+cpsyk+spsyi)(cr+sri)$
$=crcpcy-srcpcyi-crspcyj-srspcyk+crcpsyk-srcpsyj+crspsyi-srspsy$
$=(crspsy-srcpcy)i+(-crspcy-srcpsy)j+(crcpsy-srspcy)k+(crcpcy-srspsy)$

곱한 결과, 위와 같이 나오게 되고 $ijk$의 상수와 실수부를 사용해 쿼터니언을 만들면된다.
$q_x = crspsy-srcpcy$
$q_y = -crspcy-srcpsy$
$q_z = crcpsy-srspcy$
$q_w=crcpcy-srspsy$

이제 아래의 `FRotator::Quaternion` 함수를 보면, 위 결과와 동일하게 구현되어 있음을 확인할 수 있다.

```c++
FQuat FRotator::Quaternion() const
{
	...
	const float DEG_TO_RAD = PI/(180.f);
	const float RADS_DIVIDED_BY_2 = DEG_TO_RAD/2.f;
	float SP, SY, SR;
	float CP, CY, CR;

	const float PitchNoWinding = FMath::Fmod(Pitch, 360.0f);
	const float YawNoWinding = FMath::Fmod(Yaw, 360.0f);
	const float RollNoWinding = FMath::Fmod(Roll, 360.0f);

	FMath::SinCos(&SP, &CP, PitchNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SY, &CY, YawNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SR, &CR, RollNoWinding * RADS_DIVIDED_BY_2);

	FQuat RotationQuat;
	RotationQuat.X =  CR*SP*SY - SR*CP*CY;
	RotationQuat.Y = -CR*SP*CY - SR*CP*SY;
	RotationQuat.Z =  CR*CP*SY - SR*SP*CY;
	RotationQuat.W =  CR*CP*CY + SR*SP*SY;
	...

	return RotationQuat;
}
```

## 쿼터니언을 사용한 회전

다음은 언리얼 엔진에서 쿼터니언 구조체를 사용하여 벡터 V를 회전된 벡터로 리턴하는 함수이다.
왜 이런 코드로 작성되었는지 한번 알아보고자 한다.

```c++
FORCEINLINE FVector FQuat::RotateVector(FVector V) const
{	
	const FVector Q(X, Y, Z);
	const FVector T = 2.f * FVector::CrossProduct(Q, V);
	const FVector Result = V + (W * T) + FVector::CrossProduct(Q, T);
	return Result;
}
```

먼저, 단위 쿼터니언 $q$ 그리고 회전할 벡터 $V$ 주어지고, 회전된 벡터를 $Result$라고 한다면 쿼터니언 회전식은 다음과 같이 정의된다.
$Result=qpq^{-1}$ $=[W,Q][0,V][W,-Q]$  $W$는 쿼터니언 실수부, $Q$는 벡터부, $V$는 회전할 벡터

사원수의 곱은 다음과 같고, 
$q_0q_1=[s_0s_1-v_0\cdot v_1,s_0v_1+s_1v_0+v_0\times v_1]$

이를 활용해 $[W,Q][0,V][W,-Q]$ 식을 전개해보면,
$[W,Q][0,V][W,-Q]$
$=[-Q \cdot V, WV + Q \times V][W,-Q]$
$=[W(-Q \cdot V) - (WV + Q \times V) \cdot -Q), Q(Q \cdot V) + W(WV + Q \times V) + ((WV + Q \times V) \times (-Q))]$
까지 된다. 

여기서 먼저 실수부부터 전개하면
$W(-Q \cdot V) - (WV + Q \times V) \cdot -Q)$
$=[-W(Q \cdot V) + W(Q \cdot V) + Q \cdot (Q \times V)]$
$=[Q \cdot (Q \times V)]$
위와 같이 된다. 그런데, 외적의 성질에 따라 $Q \times V$ 벡터는 $Q$와 직각임으로, 서로 내적하면
$Q \cdot (Q \times V) = 0$ 이 된다. 따라서, 실수부는 0이 된다.


이제, 벡터부를 전개해보자. 벡터부는 좀 복잡하다.
$=[0 , Q(Q \cdot V) + W(WV + Q \times V) + (WV + Q \times V) \times (-Q)]$
$=[0, Q(Q \cdot V) + W^2V + W(Q \times V) -W(V \times Q) - ((Q \times V) \times Q)]$ .. 외적의 성질 참고 $(cx + y) \times z = c(x \times z) + y \times z$

단위 쿼터니언은 크기가 1로 정규화된 사원수이며, 다음 식으로 정의된다.
- $|q| = \sqrt{s^2 + |v|^2} = 1$ 
따라서, 다음식이 성립할 수 있다.
- $s^2=1-|v|^2$ 
- $s^2=1-v \cdot v$ 
마찬가지로 $W^2=1-Q \cdot Q$ 임으로, 위 식에서 $W^2$ 에 $1-Q \cdot Q$ 를 삽입하면,
$=[0, Q(Q \cdot V) + (1-Q \cdot Q)V + W(Q \times V) - W(V \times Q) - ((Q \times V) \times Q)]$ 
$=[0, Q(Q \cdot V) + (V-(V(Q \cdot Q)) + W(Q \times V) -W(V \times Q) - ((Q \times V )\times Q)]$ 

벡터삼중곱은 외적한 두 벡터에 다시 다른 벡터를 외적한 것을 말하는데 이는 다음과 같다.
- $a \times (b \times c) = b(a \cdot c) - c(a \cdot b)$
- $(a \times b) \times c = -c \times (a \times b) = - a(b \cdot c) + b(a \cdot c)$

이를 활용해 아래 파트를 다음과 같이 정리할 수 있다.
$((Q \times V) \times Q)$ 
$=-Q(Q \cdot V ) + V(Q \cdot Q)$
이를 식에 삽입하면 다음과 같다.
$=[0, Q(Q \cdot V) + V-V(Q \cdot Q) + W(Q \times V) -W(V \times Q) + Q(Q \cdot V ) - V(Q \cdot Q)]$ 

이제 같은 거 끼리 잘 묶어주면 
$=[0, V + W(Q \times V) -W(V \times Q) + 2(Q(Q \cdot V) - V(Q \cdot Q))]$ 

외적의 성질에 따라, $A \times B = - B \times A$ 임으로 아래와 같이 정리할 수 있다.
$=[0, V + 2W(Q \times V) + 2(Q(Q \cdot V) - V(Q \cdot Q))]$ 

그리고 다시 다음 파트를 벡터삼중곱을 사용하면
$Q(Q \cdot V) - V(Q \cdot Q) = Q \times (Q \times V)$  

최종적으로 다음으로 정리할 수 있겠다.
$=[0, V + 2W(Q \times V) + 2(Q \times (Q \times V))]$ 

언리얼엔진은 여기에 $2(Q \times V) = T$로 두어 다음과 같이 사용한다.
$Result=V + WT + Q \times T$

```
const FVector Result = V + (W * T) + FVector::CrossProduct(Q, T);
```
